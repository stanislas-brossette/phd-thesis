
\chapter{State of the art and Problem definition}
\label{cha:state_of_the_art_and_problem_definition}

\section{State of the art}
\label{sec:state_of_the_art}

\subsection{Inverse Kinematics}
\label{sub:inverse_kinematics}

Posture Generalization can be viewed as, and is sometimes called, Generalized Inverse Kinematics.
The Inverse Kinematics(IK) problem consists in finding the joint configuration for an articulated multibody to complete a given task.
It is, by definition purely kinematics, it has no regards for stability, or other physics related constraints.
The IK problem has been widely studied and used in the fields of robotics, computer graphics, computer games and animation.
For the simplest cases, with robotic arms that have less than 7 degrees of freedom, a closed-form solution can be found, in ~\cite{asfour2003human} the redundancy in a robot arm is exploited to devise a closed-form formula for its IK.
But for more complicated cases, optimization methods are usually used.

The Generalized Inverse Kinematics refers to a problem similar to the Inverse Kinematics in the sense that it searches a joint configuration for an articulated figure to complete a task, but it needs to do so while respecting other constraints like ensuring the stability of the structure, respecting its torque limits, avoiding collision with the environment or with itself, etc\ldots.

%Generating desired initial, intermediary or finale posture configurations requires defining static task goals (e.g.\ reach a target point in 6D) to be done under intrinsic constraints such as joint limits, torque limits, avoiding non-desired self-collisions\ldots and perceptual or extrinsic ones such as keeping an object in the embedded camera field-of-view, avoiding non-desired collisions with surrounding objects, etc.


Most approaches to solve IK problems use pseudo-inverse based methods that are the Jacobian inverse and its variations, Jacobian transpose, Damped least squares with and without Singular Values decomposition or Selectively Damped Least Squares~\cite{balestrino1984robust, tolani2000real, baillieul1985kinematic, wampler1986manipulator, nakamura1986inverse, buss2005selectively}.
Those approaches are all computationally expensive and suffer from singularities.
In~\cite{pechev2008inverse} an alternative method based on a control approach is proposed, where no matrix manipulation is required, this approach is as fast as the Damped least squares, but outperforms them in terms of handling singularities.
Some statistical resolution approaches have been proposed in~\cite{courty2008inverse, hecker2008real}, with respectively a sequential Monte Carlo method and a particle filtering approach, these approaches have the advantage to only use direct calculations and thus never require matrix inversions, thus, their strength show particularly when solving problems with high numbers of degrees of freedom.
In~\cite{AristidouFABRIK, Aristidou:2016_ExtFABRIK} the forward and backward reaching inverse kinematics(FABRIK) resolution method is proposed. It is based on a geometric iterative heuristic approach, where the bodies of a robot are moved iteratively to reach a target with the end effector.
This approach is simple, does not suffer from singularities and requires less iterations than most other IK methods.

Finding a solution to an IK problem without regards for the stability of the solution is a common approach in the field of randomized path planning. \cite{cortes2002random} proposes a method to generate many random configurations for closed loop systems with an increased probability that they be kinematically valid in terms of closure constraints, these configurations are then used in the construction of a Probabilistic RoadMap. \cite{lavalle1999probabilistic}, a similar approach is presented where instead of increasing its probability of validation, the closure constraint is enforced for each configuration by additional treatment.

\subsection{Generalized Inverse Kinematics}
\label{sub:generalized_inverse_kinematics}

All the previously mentionned approaches are used to find a robot configuration solution to the geometric IK problem.
To solve a Generalized Inverse Kinematics problem with stability constraints, one can first solve the associated IK with one of the methods presented above, and then test the stability of the IK's solution, using methods such as the ones presented in~\cite{bretl:itro:2008} or~\cite{rimon2008general} that determine if the configuration statically stable.
This gives a rejection criterion for the proposed solution.
If the solution can be stable, the optimal contact forces can be computed using method proposed in~\cite{boyd2007fast}.
Otherwise, another IK solution is generated and tested.
And the process is repeated until a satisfactory solution is found.
This type of sequencial approach of posture generation problem resolution features a rejection criterion that can in some cases be difficult to overcome, making this approach costly.
For example, if there is a small number of contacts and very few configurations are stable.
%Those approach lead to a sequential resolution of the posture generation problem where a solution to the IK problem is searched, then tested for stability, if it is stable, the optimal forces are computed, otherwise, another solution is searched for.

Another way to solve the posture generation problem is to consider the complete problem as one, with the IK targets and the other constraint (including stability) as a single nonlinear constrained optimization problem.
In~\cite{Zhao1994}, Zhao uses that approach to solve the IK problem.
That is the approach that we and many others chose to solve Generalized Inverse Kinematics problems.
In~\cite{escande:iros:2006}, that approach is used to generate postures within a growing tree type multi-contact planning algorithm, to generate a sequence of contacts sets allowing the HRP-2 robot to lean on a table to grasp an object otherwise out of reach.
Interestingly enough, in that study, the C-code that computes the robot's kinematics is generated through Maple and the HuMAnS toolbox provided by INRIA.
The constraints of contact, stability and collision are then computed on top of it.
And the problem is solved by the CFSQP solver~\cite{cfsqp:manual}.
In~\cite{hauser:ijrr:2008}, a similar posture generation approach is used to fing viable postures for different legged robots on varied terrains in the context of a Probabilistic RoadMap planning.
In~\cite{bouyarmane2010static}, Bouyarmane propose a generalization of the formulation of posture generation problems for systems of multiple robots and manipulated objects.
Also, he generalizes the notion of contacts by allowing contact to bear contact forces or not and to not necessarily be coplanar or horizontal.
This allows the generation of postures of inter-robot contacts.
He solves the complete posture generation problem with a single nonlinear constrained optimization query, computing the contact forces and joint configuration at the same time, while ensuring the stability, non collision and respect of the robots joint and torque limitations.

In the past few years, our team has dedicated considerable efforts in proposing a general multi-contact motion planner to solve cases of non-gaited acyclic planning, using a posture generator as a backbone to select valid configurations.
Given a humanoid robot, an environment, a start and a final desired postures, the planner generates a sequence of contact stances allowing any part of the humanoid to make contact with any part of the environment to achieve motion towards the goal.
The planner's role is to grow a tree of contact stances iteratively, from a given posture, it tries to removes one of its contacts or to add a new one.
The tree grows, following some heuristics until the solution is reached.
For each set of contact to add to the tree, a posture generation problem is solved in order to validate the feasibility of the set, if it is not feasible, the set is rejected.
A typical experiment with a HRP-2 robot achieving such an acyclic motion is presented in~\cite{escande:iser:2008}, and the planner is thoroughly described in~\cite{escande:ras:2013}.
Extensions of this multi-contact planner to multi-agent robots and objects gathering locomotion and manipulation are presented in~\cite{bouyarmane:ar:2012}, and preliminary validations with some DARPA challenge scenarios, such as climbing a ladder, ingress/egress a utility car or crossing through a relatively constrained pathway are presented in~\cite{bouyarmane:humanoids:2012}.
\cite{hauser:issr:2007} presents a different approach to multi-contact planning based on probabilistic roadmap and random sampling of the configuration space.
Another way of planning a multi-contact scenario, which is actually oftem used when planners fail to find satisfactory solutions, is to do it by hand, the user chooses iteratively which contacts to add and remove until the goal is reached.
This type of approach is used when the plan to execute is very complex and when a lot of fine tunning of the postures is required.
As in~\cite{vaillant:autonomousrobots:2016}, where a sequence of postures allowing the HRP-2 robot to climb a vertical ladder is generated and tuned manually.
Those postures are provided as input to a finite state machine that builds additional intermediary tasks accounting for geometric uncertainties and specific grasps procedures to be realized on the real robot by a multi-objective model-based QP controller.

\subsection{Optimization}
\label{sub:optimization}

Optimization algorithms can be derivative-free or not.
The computation of the derivatives of the functions involved in the problem is a common source of error.
The strength of the derivative-free approaches is that the user does not need to implement the derivatives.
But those approaches are much slower than their counterparts using derivatives.
One way to avoid implementation errors in the derivatives computation is to use finite differences to compute them.
This method is very slow, especially when the dimension of the problem is large.
In order to design an efficient optimization algorithm, we will focus on methods using derivative informations and will implement those derivatives computations.
The finite difference approach can be used to verify the correctness of the computation.


\section{Problem Definition}
\label{sec:problem_definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     SECTION PROBLEM DEFINITION                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We consider the problem where we have a robotic system and we want to have it do some tasks, like for example to make a contact between a point on a body of the robot and a point of the environment.
This contact task can be modelized as a simple equality.
We denote $q$ the joint configuration (joint + base) of the robot, $g(q)$ is the 3D position of the point of interest on the robot and $P$ is the point of the environment.
Then our problem comes down to finding a configuration $q^*$ such that $f(q^*) = P$.
For robots like humanoids, the equations describing their kinematics are quite complicated, and, in the presence of angular joints, they are nonlinear.
In the general case, even for simple tasks, a closed form solution of the problem does not exist.

We denote $\mathcal{C}$ the configuration space of our robotic system.
It is the manifold in which $q$ lives. The dimension of $\mathcal{C}$ is equal to the number of degrees of freedom of the robot.
Note that if all the joints of the robot are actuated, this is the number of motors of the robot.
And if the robot has a free-floating basis (is not fixed) then the position in $\mathbb{R}^3$ and rotation in $SO(3)$ of its basis are part of $q$.

We can formulate that problem as follows:

\begin{equation}
  \text{find}\ q\in\mathcal{C}\ \text{such that}\ g(q)=P
\end{equation}

The space of solution of this problem is a submanifold of $\mathcal{C}$ that we call ${\mathcal{C}}_F$ the feasible configuration space (which can be empty).

In addition to the equality constraint abovementioned, the problem can feature some inequality constraints.
For example, each joint variable can be limited to a certain range of value: $\forall i,\ q_i\in [q_i^-,\ q_i^+]$. Then the problem becomes a combination of equality and inequality constraints.%, and can be written as:
%\begin{equation}
  %\text{find}\ q\in\mathcal{C}\ \text{such that}\left\{
  %\begin{array}{l}
    %g(q)=P \\
    %\forall i,\ q_i^- \leq q_i \leq q_i^+
  %\end{array}
  %\right.
%\end{equation}
Finally, we can also require finding the point of $\mathcal{C}_F$ that minimizes a criterion, such as the distance to a goal posture $q_0$.
Our problem becomes:

\begin{equation}
  \left\{
  \begin{array}{l}
    \minimize\limits_{q\in\mathcal{C}}{\|q-q_0\|_2}\\
    \text{ s.t. }
    \left\{
    \begin{array}{l}
      g(q)=P\\
      \forall i,\ q_i^- \leq q_i \leq q_i^+
    \end{array}
    \right.
  \end{array}
  \right.
\end{equation}

This type of problem is called a nonlinear constrained optimization problem and can be formulated in a more generic fashion as:

\begin{equation}
\label{eq:optim_form_PG}
  \left\{
  \begin{array}{l}
    \minimize\limits_{x\in\mathcal{C}}{f(x)}\\
    \text{ s.t. }
    \left\{
    \begin{array}{l}
      c_i(x) = 0,\ \forall i\in{E}\\
      c_i(x) \geq 0,\ \forall i\in{I}\\
    \end{array}
    \right.
  \end{array}
  \right.
\end{equation}

Where $x$ is the optimization variable (in space $\mathcal{C}$) we want to find that minimizes the cost function $f(x)$ while satisfying the equality constraints $c_i(x) = 0,\ \forall i\in{E}$ and inequality constraints $c_i(x) \geq 0,\ \forall i\in{I}$

Such problems can be solved by a nonlinear optimization solver.
In Appendix~\ref{chapter:optimization}, we present some principles of nonlinear optimization in unconstrained and constrained cases.
Several off-the-shelf solvers are available and have been widely used in for solving robotics problems.
The CFSQP solver~\cite{cfsqp:manual} was used in~\cite{escande:iros:2009} and~\cite{escande:ras:2013} where thousands of HRP-2 posture generation queries were made to explore the feasible space.
The IPOPT solver~\cite{wachter:mathprog:2006} has been used in~\cite{vaillant:humanoids:2014},~\cite{vaillant:autonomousrobots:2016},~\cite{bouyarmane:ar:2012} where the posture generator had been extended to handle multi-robot problems and more complex and various contact models.
The SNOPT solver~\cite{gill2005snopt} was used in~\cite{dai2014whole} to plan dynamic whole-body trajectories.
Several nonlinear optimization solvers are available and have been packaged for use in robotics problems in the Roboptim Framework~\cite{moulard:jsme:2013}, such as IPOPT, CFSQP, CMinPack~\cite{cminpack}, NAG~\cite{nag}, KNITRO~\cite{knitro} and PGSolver, the solver that we develop in this thesis.

In this thesis, we use the off-the-shelf solvers IPOPT~\cite{wachter:mathprog:2006} in the beginning and later we tackle the development of our own nonlinear optimization solver and then use it.

From this point forward, we formulate and solve posture generation problems as nonlinear constrained optimization problem.
And in the next chapter, we focus on formulating several robotics constraints and cost function in the formalism of nonlinear optimization.
