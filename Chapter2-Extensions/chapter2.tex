
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           Second Chapter                            %
%                  Extensions of Posture Generation                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Extensions of Posture Generation}
\label{cha:extensions_of_posture_generation}

In this chapter we present three different and unrelated contributions to the state of the art of posture generation.
First we present a novel method called Integration of Non-Inclusive Contacts in Posture Generation that was published in~\cite{brossette:iros:2014}.
Second we present a generic algorithm to compute efficiently the derivative of the joint torques of a robot.
Third we present our endeavour to apply an optimization method called `Lifted Newton Method', presented in~\cite{Albersmeyer:2010:LNM:1958447.1958472}, to problems of inverse kinematics.



\section{List of contributions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                  SECTION LIST OF CONTRIBUTIONS                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
  \item The method presented before is limiting in many cases. Ladder, stairs climbing\dots.
Sometimes it is not possible to ensure inclusion of 2 surfaces.
  \item Contact geometry formulation
    \begin{itemize}
      \item Discretisation of contact surfaces for practical reasons
      \item Contact generation with convex surface inclusions
Usual methods for generating surface contact are based on point-to-point sampling, on rectangular inclusion, or other limiting methods. We extend that to the inclusion of convex surfaces.
      \item Inclusive contacts are no problem
      \item Non-Inclusive contacts lead to non-constant number of constraints or non-smooth gradients, cannot be solved with usual solvers with that formulation
    \end{itemize}
  \item{Non inclusive contact constraints}
    \begin{itemize}
      \item {Main Idea: Inserting an ellipse in the intersection of polygons}
      \item {Pseudo-distance (to simplify the formulation)}
      \item {Modification of the optimization problem}
      \item {Maximization of the contact area}
      \item {Using non inclusive contact to maintain stability}
      \item {Extension to singular cases}
    \end{itemize}
  \item{Simulation Results}
    \begin{itemize}
      \item{Inclined ladder climbing}
      \item{Vertical ladder climbing}
      \item{Climbing Stairs}
      \item{Walking along a path made of small objects}
    \end{itemize}
  \item{Application to ladder climbing (cf. Joris papers)}
\end{itemize}

\paragraph{Torque Derivation}

\paragraph{On the use of lifted variables for Robotics Posture Generation}
\begin{itemize}
  \item {Introduction: `J. Albersmeyer and M. Diehl, The lifted Newton Method and its Application in Optimisation'}
  \item {Lifting Algorithm: Introduce additional variables to reduce the complexity/degree of the equations to solve. And then use a trick to re-condense the system and avoid loosing computation time}
  \item {Optimization on lifted variables}
  \item {Condensed BFGS update}
  \item {Results, experimentation}
  \begin{itemize}
    \item Symbolic Inverse Kinematics
    \item Automatic Lifting algorithm adapted to posture generation
    \item Several Solvers for lifted and non-lifted systems (Gauss Newton, SQP, lifted Newton\ldots)
    \item Compared many optimization methods (Globalization, regularization\ldots)
    \item Never managed to get results faster than basic methods
  \end{itemize}
  \item{Motivation:Development of a posture generator with a specialized solver}
    \begin{itemize}
      \item Problem
        \begin{itemize}
          \item Robotics problems solved with generic solvers (IPOPT, CFSQP, fmincon\ldots)
          \item Robotics problems (especially posture generation) are very specific (Constraints, costs, working spaces, sizes\ldots)
        \end{itemize}
      \item Solution
        \begin{itemize}
          \item Develop a posture generator, along with a non-linear solver
          \item Better understanding of our own solver
          \item Ability to use the solver in new ways:
          \begin{itemize}
            \item Working on Manifolds
            \item Variable numbers of constraints
            \item Automatic management of variables, constraints and mathematical expressions
          \end{itemize}
        \end{itemize}
    \end{itemize}
\end{itemize}



\section{Integration on Non-Inclusive Contacts in Posture Generation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  SECTION INTEGRATION ON NON-INCLUSIVE CONTACTS IN POSTURE GENERATION  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The method presented before is still limiting in many cases. Ladder, stairs climbing\dots.
Sometimes it is not possible to ensure inclusion of 2 surfaces.

\subsection{Contact geometry formulation}
\label{sec:background}
Present the difficulties related to intersecting 2 convex polygons. Non-constant number of constraints.
Usual solution: patching

\subsection{Non inclusive contact constraints}
\subsubsection{Main Idea}
\subsubsection{Pseudo-distance}
\subsubsection{Modification of the optimization problem}
\subsubsection{Maximixation of the contact area}
\subsubsection{Using non inclusuve contact to maintain stability}
\subsubsection{Extension to singular cases}
\subsection{Simulation Results}
\subsubsection{Inclined ladder climbing}
\subsubsection{Vertical ladder climbing}
\subsubsection{Climbing Stairs}
\subsubsection{Walking along a path made of small objects}



\section{Torque derivation}
\label{sec:torque_derivation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     SECTION TORQUE DERIVATION                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The computation of the torque jacobian $\frac{\partial \tau}{\partial q}$ with respect to the articular parameters is done by differenciating algorithm~\ref{IS}.
We first write algorithm~\ref{IS} in its matrix form.

\begin{algorithm}
  \caption{Inverse Static Matrix form}
\label{ISmatrix}
\begin{algorithmic}
  \For{$i = 0:n_B$}\\
  $f^G_i =
  \begin{pmatrix}
    \mathbf{m}^{G}_i \\ \mathbf{f}^{G}_i
  \end{pmatrix}
  =
  \mathbf{I}^W
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & \mathbf{0} \\
    -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{ac} \\ \mathbf{af}
  \end{pmatrix}
  -
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} \\
    \mathbf{0} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{m}^{ext}_i \\ \mathbf{f}^{ext}_i
  \end{pmatrix}
  $
  \EndFor{}
  \For{$i = n_J-1:0$}
  \State$\tau_i = {f^G_i}^T S_i$
  \If{$pred(i) \neq -1$}
  \State$f^G_{pred(i)} =
  \begin{pmatrix}
    \mathbf{m}^{G}_{pred(i)} \\ \mathbf{f}^{G}_{pred(i)}
  \end{pmatrix}
  +=
  \begin{pmatrix}
    {\mathbf{R}^{PtS}_i}^T & \widehat{\mathbf{t}^{PtS}_i}{\mathbf{R}^{PtS}_i}^T \\
    \mathbf{0} & {\mathbf{R}^{PtS}_i}^T \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{m}^{G}_i \\ \mathbf{f}^{G}_i
  \end{pmatrix}
  $
  \EndIf{}
  \EndFor{}
\end{algorithmic}
\end{algorithm}

The variables of this algorithm w.r.t which we need to differenciate it are the geometric parameters of the robot $q$ and the variables of the external wrenches which can contain $q$ and some other variables $y$.
We assume that the derivatives of $m_i^{ext}$ and $f_i^{ext}$: $\frac{\partial m_i^{ext}}{\partial q}$, $\frac{\partial m_i^{ext}}{\partial y}$, $\frac{\partial f_i^{ext}}{\partial q}$ and $\frac{\partial f_i^{ext}}{\partial y}$ are known.

Besides $m_i^{ext}$ and $f_i^{ext}$ all the quantities of the algorithm depend only on $q$.
Therefore, the derivation w.r.t $y$ is trivial and is automatically computed by our final algorithm.
From here we will focus on the derivation w.r.t $q$.

Note the following relations:
\begin{align}
  \frac{\partial {}^i\mathbf{R}_W \mathbf{u}}{\partial q_j}
  &= {}^i\mathbf{R}_W \mathbf{u} \wedge \omega_{i,j}
  = {}^i\mathbf{R}_W \widehat{\mathbf{u}} \omega_{i,j}
  \\
  \frac{\partial {}^i\mathbf{R}_W {}^i\mathbf{t}_W\wedge \mathbf{u}}{\partial q_j}
  &= {}^i\mathbf{R}_W \mathbf{v}_{i,j} \wedge \mathbf{u}
  + {}^i\mathbf{R}_W \left({}^i\mathbf{t}_W\wedge\mathbf{u}\right) \wedge \omega_{i,j}\\
  &= -{}^i\mathbf{R}_W \widehat{\mathbf{u}} \mathbf{v}_{i,j}
  + {}^i\mathbf{R}_W \widehat{\left(\widehat{{}^i\mathbf{t}_W}\mathbf{u}\right)} \omega_{i,j}
\end{align}

Let's differentiate the first equation of~\ref{ISmatrix} w.r.t $q_j$.

\begin{align}
  A &=
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & \mathbf{0} \\
    -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{ac} \\ \mathbf{af}
  \end{pmatrix} \\
  B &=
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} \\
    \mathbf{0} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{m}^{ext}_i \\ \mathbf{f}^{ext}_i
  \end{pmatrix} \\
  f^G_i &= \mathbf{I}^W A-B\\
  \frac{\partial A}{\partial q_j} &=
  \begin{pmatrix}
    {}^i\mathbf{R}_W \widehat{\bf ac} \omega_{i,j}\\
    -{{}^i\mathbf{R}_W}\widehat{\left(\widehat{{}^i\mathbf{t}_W}{\bf ac} \right)}\omega_{i,j}
    + {{}^i\mathbf{R}_W}\widehat{\bf ac} v_{i,j} + {}^i\mathbf{R}_W \widehat{\bf af} \omega_{i,j}\\
  \end{pmatrix}
  \\
  \frac{\partial B}{\partial q_j} &=
  \begin{pmatrix}
    - {{}^i\mathbf{R}_W}\widehat{\left(\widehat{{}^i\mathbf{t}_W}\bf \mathbf{f}^{ext}_i \right)}\omega_{i,j}
    + {{}^i\mathbf{R}_W}\widehat{\bf \mathbf{f}^{ext}_i} v_{i,j} + {}^i\mathbf{R}_W \widehat{\bf \mathbf{m}^{ext}_i} \omega_{i,j}\\
    {}^i\mathbf{R}_W \widehat{\bf \mathbf{f}^{ext}_i} \omega_{i,j}\\
  \end{pmatrix}
  \\&+
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} \\
    \mathbf{0} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \frac{\partial \mathbf{m}^{ext}_i}{\partial q} \\ \frac{\partial \mathbf{f}^{ext}_i}{\partial q}
  \end{pmatrix}
\end{align}

Putting all the pieces of $\omega$ and $v$ allows to group all the j-derivatives to obtain the jacobian of $f^G_i$ with a single equation.

\begin{align}
  \bf M &=
  \begin{pmatrix}
    {}^i\mathbf{R}_W \widehat{\bf ac}  & 0\\
    -{{}^i\mathbf{R}_W}\widehat{\left(\widehat{{}^i\mathbf{t}_W}\bf ac \right)}
    + {}^i\mathbf{R}_W \widehat{\bf af}  & {{}^i\mathbf{R}_W}\widehat{\bf ac} \\
  \end{pmatrix}
  \\
  \bf N &=
  \begin{pmatrix}
    - {{}^i\mathbf{R}_W}\widehat{\left(\widehat{{}^i\mathbf{t}_W}\bf \mathbf{f}^{ext}_i \right)} + {}^i\mathbf{R}_W \widehat{\bf \mathbf{m}^{ext}_i} & {{}^i\mathbf{R}_W}\widehat{\bf \mathbf{f}^{ext}_i} \\
    {}^i\mathbf{R}_W \widehat{\bf \mathbf{f}^{ext}_i} & 0\\
  \end{pmatrix}
  \\
  \frac{\partial f^G_i}{\partial q} &= (\mathbf{I}^W \mathbf{M} - \mathbf{N})\mathbf{Jac}^W_i
  +
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} \\
    \mathbf{0} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \frac{\partial \mathbf{m}^{ext}_i}{\partial q} \\ \frac{\partial \mathbf{f}^{ext}_i}{\partial q}
  \end{pmatrix}
\end{align}

The derivation of the second equation is obvious:

\begin{align}
  \tau_i &= {f^G_i}^T S_i \\
  \frac{\partial \tau_i}{\partial q} &= S_i^T \frac{\partial f^G_i}{\partial q} \\
\end{align}

Note the following relations:
\begin{align}
  \frac{\partial {\mathbf{R}_i^J}^T \mathbf{u}}{\partial q_j}
  &= - S^R_{i,j} \wedge ({\mathbf{R}_i^J}^T \mathbf{u})
  = \widehat{({\mathbf{R}_i^J}^T \mathbf{u})} S^R_{i,j}
  \\
  \frac{\partial\mathbf{t}^J_i\wedge {\mathbf{R}_i^J}^T  \mathbf{u}}{\partial q_j}
  &= S^t_{i,j} \wedge \left({\mathbf{R}_i^J}^T \mathbf{u}\right)
  - \mathbf{t}^J_i \wedge \left( S^R_{i,j} \wedge \left({\mathbf{R}_i^J}^T \mathbf{u}\right)\right) \\
  &= -\widehat{({\mathbf{R}_i^J}^T \mathbf{u})} S^t_{i,j}
  + \left(\left({\mathbf{R}_i^J}^T \mathbf{u}\right) \cdot {\mathbf{t}^J_i}^T
  - \left( {({\mathbf{R}_i^J}^T \mathbf{u})}^T \cdot \mathbf{t}^J_i\right) \mathbf{I}_3\right)S_{i,j}^R\\
\end{align}

The last equation's derivation goes like follows:

\begin{align}
  f^G_{pred(i)} & +=
  \begin{pmatrix}
    {\mathbf{R}^{PtS}_i}^T & \widehat{\mathbf{t}^{PtS}_i}{\mathbf{R}^{PtS}_i}^T \\
    \mathbf{0} & {\mathbf{R}^{PtS}_i}^T \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{m}^{G}_i \\ \mathbf{f}^{G}_i
  \end{pmatrix}
  \\
  & += \begin{pmatrix}
    {\mathbf{R}^{x}_i}^T & \widehat{\mathbf{t}^{x}_i}{\mathbf{R}^{x}_i}^T \\
    \mathbf{0} & {\mathbf{R}^{x}_i}^T \\
  \end{pmatrix}
  \begin{pmatrix}
    {\mathbf{R}^{J}_i}^T & \widehat{\mathbf{t}^{J}_i}{\mathbf{R}^{J}_i}^T \\
    \mathbf{0} & {\mathbf{R}^{J}_i}^T \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{m}^{G}_i \\ \mathbf{f}^{G}_i
  \end{pmatrix}
  \\
  K_i &=
  \begin{pmatrix}
    \widehat{({\mathbf{R}_i^J}^T \mathbf{m}^{G}_i)}
    + \left({\mathbf{R}_i^J}^T \mathbf{f}^{G}_i\right) \cdot {\mathbf{t}^J_i}^T
    - \left( {({\mathbf{R}_i^J}^T \mathbf{f}^{G}_i)}^T \cdot \mathbf{t}^J_i\right) \mathbf{I}_3
    & -\widehat{({\mathbf{R}_i^J}^T \mathbf{f}^{G}_i)} \\
    \widehat{({\mathbf{R}_i^J}^T \mathbf{f}^{G}_i)} & 0
  \end{pmatrix}
  \\
  \frac{\partial f^G_{pred(i)}}{\partial q} & -=
  \begin{pmatrix}
    {\mathbf{R}^{x}_i}^T & \widehat{\mathbf{t}^{x}_i}{\mathbf{R}^{x}_i}^T \\
    \mathbf{0} & {\mathbf{R}^{x}_i}^T \\
  \end{pmatrix}
  K_i S_i
\end{align}


The entire algorithm for calculating the torque jacobian w.r.t the articular parameters comes down to:

\begin{algorithm}
  \caption{Torque Jacobian Calculation}
\label{TJC}
\begin{algorithmic}
  \For{$i = 0:n_B$}
  \State{Compute the Jacobian of generalized forces}
  \State$f^G_i =
  \mathbf{I}^W
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & \mathbf{0} \\
    -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{ac} \\ \mathbf{af}
  \end{pmatrix}
  -
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} \\
    \mathbf{0} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \mathbf{m}^{ext}_i \\ \mathbf{f}^{ext}_i
  \end{pmatrix}
  $
  \State$\bf M =
    \begin{pmatrix}
    {}^i\mathbf{R}_W \widehat{\bf ac}  & 0\\
    -{{}^i\mathbf{R}_W}\widehat{\left(\widehat{{}^i\mathbf{t}_W}\bf ac \right)}
    + {}^i\mathbf{R}_W \widehat{\bf af}  & {{}^i\mathbf{R}_W}\widehat{\bf ac} \\
    \end{pmatrix}
    $
  \State$\bf N =
  \begin{pmatrix}
    - {{}^i\mathbf{R}_W}\widehat{\left(\widehat{{}^i\mathbf{t}_W}\bf \mathbf{f}^{ext}_i \right)}
    + {}^i\mathbf{R}_W \widehat{\bf \mathbf{m}^{ext}_i}
    & {{}^i\mathbf{R}_W}\widehat{\bf \mathbf{f}^{ext}_i} \\
    {}^i\mathbf{R}_W \widehat{\bf \mathbf{f}^{ext}_i} & 0\\
  \end{pmatrix}
  $
  \State$
  \frac{\partial f^G_i}{\partial q} = (\mathbf{I}^W \mathbf{M} - \mathbf{N})\mathbf{Jac}^W_i
  +
  \begin{pmatrix}
    {{}^i\mathbf{R}_W} & -{{}^i\mathbf{R}_W}\widehat{{}^i\mathbf{t}_W} \\
    \mathbf{0} & {{}^i\mathbf{R}_W} \\
  \end{pmatrix}
  \begin{pmatrix}
    \frac{\partial \mathbf{m}^{ext}_i}{\partial q} \\ \frac{\partial \mathbf{f}^{ext}_i}{\partial q}
  \end{pmatrix}
  $
  \EndFor{}
  \For{$i = n_J-1:0$}
  \State{Compute the Jacobian of torques w.r.t q}
  \State$\frac{\partial \tau_i}{\partial q} = S_i^T \frac{\partial f^G_i}{\partial q}$
  \If{$pred(i) \neq -1$}
  \State$\mathbf{K} =
  \begin{pmatrix}
    \widehat{({\mathbf{R}_i^J}^T \mathbf{m}^{G}_i)}
    + \left({\mathbf{R}_i^J}^T \mathbf{f}^{G}_i\right) \cdot {\mathbf{t}^J_i}^T
    - \left( {({\mathbf{R}_i^J}^T \mathbf{f}^{G}_i)}^T \cdot \mathbf{t}^J_i\right) \mathbf{I}_3
    & -\widehat{({\mathbf{R}_i^J}^T \mathbf{f}^{G}_i)} \\
    \widehat{({\mathbf{R}_i^J}^T \mathbf{f}^{G}_i)} & 0
  \end{pmatrix}$
  \State$f^G_{pred(i)} += {\mathbf{X}^{PtS}_i(q)}^{-*} f^G_i$
  \State$\frac{\partial f^G_{pred(i)}}{\partial q} -=
  \begin{pmatrix}
    {\mathbf{R}^{x}_i}^T & \widehat{\mathbf{t}^{x}_i}{\mathbf{R}^{x}_i}^T \\
    \mathbf{0} & {\mathbf{R}^{x}_i}^T \\
  \end{pmatrix}
  \mathbf{K} S_i$
  \EndIf{}
  \EndFor{}
\end{algorithmic}
\end{algorithm}


\section{On the use of lifted variables for Robotics Posture Generation}
\label{sec:liftedVariables}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION ON THE USE OF LIFTED VARIABLES FOR ROBOTICS POSTURE GENERATION  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Introduction}
\label{subsec:Introduction}

\subsection{Lifting Algorithm}
\label{subsec:LiftingAlgorithm}

\subsection{Optimization on lifted variables}
\label{subsec:optimization_on_lifted_variables}

\subsection{Condensed BFGS update}
\label{subsec:condensed_bfgs_update}

\subsection{Results, experimentation}
\label{subsec:Results}

\subsection{conclusion}
\label{subsec:conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%
%  SECTION CONCLUSION  %
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Discussion and conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           SECTION DISCUSSION AND CONCLUSION                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

All that is very nice, but still many limitations and possible improvements.
Transition to Posture generation on Non-Euclidean Manifolds.



